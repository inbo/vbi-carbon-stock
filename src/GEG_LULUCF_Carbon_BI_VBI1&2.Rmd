---
title: "Carbon uptake volgens INBO-advies A.3104 (methode 4b) - met betrouwbaarheidsinterval"
author: "Anja Leyman, Leen Govaere, Toon Westra"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    fig_caption: yes
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: FALSE
      smooth_scroll: FALSE
bibliography: reference.bib

---

```{r Rm, eval = FALSE}
rm(list=ls())
```


```{r Setup, include = FALSE}
library(knitr)
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE, 
  fig.width = 9,
  fig.align = TRUE)

library(tidyverse)
library(RODBC)
library(here)
library(DT)
library(openssl)
library(kableExtra)
library(lme4)
library(Partiallyoverlapping)
library(DHARMa)
library(readxl)
library(tidyr)
library(broom)

source(here::here('src/VBI_Functies.R'))
source(here::here('src/VBI3_Functies.R'))

scriptNaam <- "GEG_LULUCF_Carbon_BI.Rmd"
Verzoek <-  "LULUCF_ANB"
# run <- "run_AL"
run <- "test_AL"
```


# Vraagstelling

**Adviesvraag vanuit ANB**
In het advies INBO.A.4103 uit 2020 ontvingen we een ontwerp-berekening voor de C-voorraad op basis van de bosinventarisatie.

https://www.vlaanderen.be/inbo/publicaties/advies-over-de-berekening-van-de-koolstofvoorraad-en-de-evolutie-daarvan-in-de-biomassa-van-vlaamse-bossen

Hoe kan het betrouwbaarheidsinterval berekend worden op de toename of afname van C/ha/jaar ?

**Verduidelijking**

Het betrouwbaarheidsinterval heeft betrekking op de onzekerheid door het nemen van een steekproef, maar zegt niks over de onzekerheid op de volumebepaling of de omzetting naar biomassa mbv houtdensiteiten. 


# Methodiek C-berekening

**Algemeen**

De carbon uptake factor wordt berekend volgens de stock change methode (eq. 3.2.3. IPCC LULUCF): 

$$\ C{{uptake}} = \frac{\left(\ C2 - C1 \right)}{\left(\ t2 - t1 \right)}$$


met 

- C~uptake~ = Carbon uptake factor (tC/ha/jaar)
- C1: carbon stock at time 1 (tC/ha)
- C2: carbon stock at time 1 (tC/ha)
- t1: time 1
- t2: time 2

en 

$$\ C = \ V *  BEF * WD * \left(\ 1 + R \right) * FC$$

met 

- C = carbon stock (tC/ha)
- V = stamvolume > 7 cm (m³/ha)
- BEF = branch/biomass expansion factor: BEF/VEF van Longuetaud: biomass expansion factors afh. van boomsoort, diameter en hoogte
- WD = wood density: om van volume naar biomassa over te gaan (t/m³), cfr FRL
- FC = carbon factor: ton C/ton droge biomassa (= 0.5)
- R = verhouding ondergrondse biomassa tov bovengrondse biomassa, cfr FRL

<br>

**Concreet**

Methode 4b uit het INBO-advies berekent koolstof en biomassa conform de FRL:   

- mbv BEF/VEF van Longuetaud (afh. van boomsoort, diameter en hoogte)
- factoren cfr. FRL (R, FC, WD)

Aangezien de factoren van Longuetaud niet enkel boomsoort-afhankelijk zijn, maar 
ook bepaald worden door diameter en hoogte van de boom, wordt bij de berekening vertrokken van individuele boommetingen.
(zie script `GEG_VolumeBiomassCarbon_aanmaak_analyseset.Rmd`)

<br>

# Referentie

Note technique version 20/11/2017. Estimation du volume et biomasse de différents compartiments de l’arbre. 
Accompagnement scientifique de l’IPRFW. ULiège - Wallonie environnement SPW.

<br>


# Invoer gegevens 

In script `GEG_VolumeBiomassCarbon_aanmaak_analyseset.Rmd` wordt de analyseset aangemaakt op plotniveau:  
- enkel productieve bosplots 
- met toevoeging van plots zonder biomassa (stamtal/volume = 0)

Deze analyseset (`tblLULUCF_analyseset_plot`) kan opgehaald worden uit de analysedb of via Rdata.

```{r , warning=FALSE}
# save(analyseset_plot, file = here::here("Scripts/Analysedatabank/Rdata/LULUCF_analyseset_plot.Rdata"))

load(here::here("data/LULUCF_analyseset_plot.Rdata"))

gepaardheid <- read_excel(here::here("data/tblRepeatedMeasurement.xlsx"),
                          guess_max = 1e5)

gepaardheid_1_2 <- gepaardheid %>%
  filter(timespan == "1_2") %>%
  select(idplots, rm_dendro) %>%
  mutate(rm_dendro = as.logical(rm_dendro))

check <- n_distinct(gepaardheid_1_2$idplots) == nrow(gepaardheid_1_2)
```


```{r}
show_ci <- function(mean, llci, ulci, digits = 2){
  
  result <- str_c(round(mean, digits), " [", round(llci, digits), " - ", round(ulci, digits), "]")
  
  return(result)
  
  }
```


# Aanmaak analyseset

```{r KiesPeriode1&2}
analyseset <- analyseset_plot %>% 
   filter(Periode %in% c(1,2)) %>%
   select(idplots = IDPlots, Periode, Weight, Year, Reeks, Carbon_t_ha, idgroup) %>%
  left_join(gepaardheid_1_2, by = "idplots")

duur_periode <- analyseset_plot %>%
  group_by(Periode) %>%
  summarise(mean_year = mean(Year)) %>%
  ungroup()
```

# Design-based analyse

## C/ha per periode

```{r statistics_per_periode, results = 'hide'}

p1 <- My.WgtParEstimation(analyseset, VariableName = "Carbon_t_ha", Periode = 1)

p2 <- My.WgtParEstimation(analyseset, VariableName = "Carbon_t_ha", Periode = 2)

result_db <- rbind(p1, p2)

colnames(result_db) <- str_to_lower(colnames(result_db))
```

## Toename of afname C/ha/jaar

```{r create_results_wide, results='hide'}
# van long naar wide
# dan aftrekken en delen door 16, 14.2,.. ...10

n_years_mean <- mean((analyseset %>%
       filter(Periode == 2))$Year) -
  mean((analyseset %>%
       filter(Periode == 1))$Year)

periode_jaar <- analyseset %>%
  group_by(Periode) %>%
  summarise(year_mean = mean(Year),
            year_middle = (max(Year) - min(Year))/2 + min(Year)) %>%
  ungroup() %>%
  pivot_longer(cols = c("year_mean", "year_middle"), names_to = "type", values_to = "year") %>%
  pivot_wider(names_from = "Periode", names_prefix = "periode_", values_from = c("year")) %>%
  mutate(diff_n_years = periode_2 - periode_1)


result_db_diff <- result_db %>%
  select(variabele, periode, mean = wgt.mean, se, llci, ulci) %>%
  pivot_wider(names_from = "periode", values_from = c("mean", "se", "llci", "ulci")) %>%
  bind_cols(periode_jaar) %>%
  mutate(
    verschil = mean_2 - mean_1,
    verschil_se = sqrt(se_1^2 + se_2^2),
    llci = verschil - 1.96 * verschil_se,
    ulci = verschil + 1.96 * verschil_se,
    verschil_jaar = verschil/diff_n_years,
    verschil_jaar_se = verschil_se/diff_n_years,
    verschil_jaar_llci = llci/diff_n_years,
    verschil_jaar_ulci = ulci/diff_n_years
  )

```

## Betrouwbaarheidsinterval: 2 onafhankelijke steekproeven

Als we twee onafhankelijke steekproeven veronderstellen (wat niet het geval is) kunnen we eenvoudig de standaardfout berekenen op het verschil tussen de gemiddeldes per periode. Omdat we negeren dat een deel van de observaties gepaard zijn, krijgen we hierdoor echter een breder betrouwbaarheidsinterval (lagere precisie).  

$$\text{SE}_{{C}_2-{C}_1}= \sqrt{\text{SE}_{{C}_2}^2 + \text{SE}_{{C}_1}^2}$$
Het aantal jaren tussen de inventarisaties berekenen we op twee manieren:

+ het verschil tussen het middelste jaar van elke inventarisatie (zoals het vorige advies suggereert): 16 jaar
+ het verschil tussen het gemiddelde jaar van opname van elke inventarisatie (lijkt me correcter): 15,2 jaar


```{r table_results}
result_onafh <- result_db_diff %>% 
  mutate(verschil_jaar = show_ci(verschil_jaar, verschil_jaar_llci, verschil_jaar_ulci),
        periode_1 = show_ci(mean_1, llci_1, ulci_1),
        periode_2 = show_ci(mean_2, llci_2, ulci_2),
        diff_n_years = round(diff_n_years, 2)) %>%
  select(variabele,
         "Periode 1" = periode_1,
         "Periode 2" = periode_2,
         "Tijdsverschil (jaren)" = diff_n_years,
         "Jaarlijkse toename" = verschil_jaar) 

result_onafh %>% 
  datatable(rownames = FALSE,
            caption = "Schatting jaarlijkse toename in C per ha en 95% betrouwbaarheidsinterval bij een veronderstelling dat beide steekproeven onafhankelijk zijn")

```


## Betrouwbaarheidsinterval: (deels) gepaarde metingen

```{r}
analyseset <- analyseset %>%
  group_by(idplots) %>%
  mutate(n_periods = n_distinct(Periode)) %>%
  ungroup() %>%
  mutate(observation_type = ifelse(is.na(rm_dendro) | n_periods == 1, "not repeated",
                                   ifelse(rm_dendro, "repeated & paired", "repeated & unpaired")))

check <- analyseset %>%
  group_by(Periode, observation_type, n_periods) %>%
  summarise(n = n()) %>%
  ungroup()
```


```{r}
analyseset %>%
  select(idplots, observation_type, Periode, Carbon_t_ha) %>%
  ggplot(aes(x = observation_type, y = Carbon_t_ha,
             fill = factor(Periode))) +
  geom_violin(alpha = 0.1) +
  labs(y = "Koolstof (ton/ha)",
       x = "",
       fill = "Periode")
```


```{r}
carbon_periodes <- analyseset %>%
  filter(observation_type %in% c("repeated & paired", "repeated & unpaired")) %>%
  select(idplots, observation_type, Periode, Carbon_t_ha) %>%
  pivot_wider(names_from = "Periode", values_from = "Carbon_t_ha", names_prefix = "periode_")

carbon_periodes %>%
  ggplot(aes(x = periode_1, y = periode_2)) +
  geom_point(alpha = 0.2) +
  geom_smooth() +
  geom_abline(intercept = 0, slope = 1, linetype = 2) +
  facet_wrap(~observation_type) +
  labs(x = "Koolstof (ton/ha) periode 1",
       y = "Koolstof (ton/ha) periode 2")

```



N.B. de "repeated & unpaired" categorie omvat proefvlakken die in de tweede periode niet exact geherlokaliseerd konden worden.
Deze categorie bevat ook de bosrand proefvlakken die in de eerste periode systematisch verschoven werden om volledig binnen bos te liggen, maar in de tweede periode niet verschoven werden (om geen vertekening te veroorzaken).

```{r}
unpaired <- analyseset %>%
  filter(observation_type %in% c("not repeated", "repeated & unpaired"))

paired_p1_p2 <- analyseset %>%
  filter(observation_type == "repeated & paired") %>%
  select(idplots, Year, Weight, Periode, Carbon_t_ha) %>%
  pivot_wider(names_from = "Periode", values_from = c("Year", "Weight", "Carbon_t_ha")) %>%
  mutate(n_years = Year_2 - Year_1,
         carbon_t_ha_diff_total = Carbon_t_ha_2 - Carbon_t_ha_1,
         carbon_t_ha_diff_year = carbon_t_ha_diff_total/n_years)

mean_year_paired <- mean(paired_p1_p2$n_years)
mean_carbon_paired <- mean(paired_p1_p2$carbon_t_ha_diff_year)
```


### Aparte schatting gepaarde en niet-gepaarde plots

+ Voor de gepaarde metingen kunnen we op plotniveau de toename in C per ha per jaar bepalen. Dit is correcter gezien de periode tussen de herhaalde metingen varieert van plot tot plot. 

```{r}
results_paired <- paired_p1_p2 %>%
  mutate(Weight = Weight_2,
         Year = Year_2,
         Reeks = 1) %>%
  My.WgtParEstimation(VariableName =  c("carbon_t_ha_diff_year", "carbon_t_ha_diff_total"))

```

+ voor de niet-gepaarde metingen berekenen we het verschil in gemiddelde houtvoorraad periode en delen we die door het verschil in gemiddelde jaar waarin de opname is gebeurd.
+ N.B. niet-gepaarde metingen zijn hier de combinatie van de categorieën "not repeated" en "repeated & unpaired". Dit is een strikte interpretatie van niet-gepaard, omdat de categorie "repeated & unpaired" in feite kan beschouwd worden als deels gepaard (de locatie is niet exact dezelfde waardoor het zeer waarschijnlijk gaat om metingen aan andere bomen, maar de locatie zal wel nabij gelegen zijn, waardoor we correlatie verwachten)


```{r}
results_unpaired_periode1 <- unpaired %>%
  My.WgtParEstimation(VariableName =  "Carbon_t_ha", Periode = 1)

results_unpaired_periode2 <- unpaired %>%
  My.WgtParEstimation(VariableName =  "Carbon_t_ha", Periode = 2)

periode_jaar_unpaired <- unpaired %>%
  group_by(Periode) %>%
  summarise(year_mean = mean(Year),
            year_middle = (max(Year) - min(Year))/2 + min(Year)) %>%
  ungroup() %>%
  pivot_longer(cols = c("year_mean", "year_middle"), names_to = "type", values_to = "year") %>%
  pivot_wider(names_from = "Periode", names_prefix = "periode_", values_from = c("year")) %>%
  mutate(diff_n_years = periode_2 - periode_1)

results_unpaired <- results_unpaired_periode1 %>%
  bind_rows(results_unpaired_periode2) 

colnames(results_unpaired) <- str_to_lower(colnames(results_unpaired))

results_unpaired_wide <- results_unpaired %>%
  select(variabele, periode, nbobservaties, mean = wgt.mean, se, llci, ulci) %>%
  pivot_wider(names_from = "periode", values_from = c("nbobservaties", "mean", "se", "llci", "ulci")) %>%
  bind_cols(periode_jaar_unpaired) %>%
  mutate(
    verschil = mean_2 - mean_1,
    verschil_se = sqrt(se_1^2 + se_2^2),
    llci = verschil - 1.96 * verschil_se,
    ulci = verschil + 1.96 * verschil_se,
    verschil_jaar = verschil/diff_n_years,
    verschil_jaar_se = verschil_se/diff_n_years,
    verschil_jaar_llci = llci/diff_n_years,
    verschil_jaar_ulci = ulci/diff_n_years,
    variabele = "carbon_t_ha_diff_year"
  )
```

Dit geeft volgende resultaten:

```{r}
results_paired_summary <- results_paired %>%
  mutate(observation_type = "gepaard",
         verschil_jaar = str_c(round(wgt.mean, 2), " [", round(llci, 2), " - ", round(ulci, 2), "]")) %>%
  select(variabele, observation_type,  "Jaarlijkse toename" = verschil_jaar) 
  
results_unpaired_summary <- results_unpaired_wide %>%
  mutate(observation_type = "ongepaard",
         diff_n_years = round(diff_n_years, 2),
         verschil_jaar = str_c(round(verschil_jaar, 2), " [", round(verschil_jaar_llci, 2), " - ", round(verschil_jaar_ulci, 2), "]")) %>%
  select(variabele, observation_type, "Tijdsverschil (jaren)" = diff_n_years,  "Jaarlijkse toename" = verschil_jaar) 

results_paired_summary %>%
  bind_rows(results_unpaired_summary) %>%
  datatable(rownames = FALSE)
```

Vervolgens kunnen we gemiddelde nemen van de jaarlijkse toename voor de gepaarde en ongepaarde plots, gewogen volgens de som van de plotgewichten. 

De standaardfout op dit gewogen gemiddelde berekenen we als volgt:

$$\text{SE}_{{C}_2-C_1}= \sqrt{w_{gepaard}^2\text{SE}_{({C}_2-C_1)_{gepaard}}^2 + w_{ongepaard}^2\text{SE}_{({C}_2-C_1)_{ongepaard}}^2}$$


```{r}
n_paired <- sum(paired_p1_p2$Weight_2, paired_p1_p2$Weight_1) 

n_unpaired <- sum(unpaired$Weight)

# n_paired <- nrow(paired_p1_p2) * 2
# 
# n_unpaired <- nrow(unpaired)

weight_paired <- n_paired / (n_paired + n_unpaired)

weight_unpaired <- n_unpaired / (n_paired + n_unpaired)

results_unpaired_wgt <- results_unpaired_wide %>%
  select(variabele, verschil_jaar_unpaired = verschil_jaar, verschil_jaar_unpaired_se = verschil_jaar_se, diff_n_years) %>%
  mutate(weight_unpaired = weight_unpaired)

results_paired_wgt <- results_paired %>%
  select(variabele, verschil_jaar_paired = wgt.mean, verschil_jaar_paired_se = se) %>%
  mutate(weight_paired = weight_paired) %>%
  filter(variabele == "carbon_t_ha_diff_year")

results_wgt <- results_unpaired_wgt %>%
  left_join(results_paired_wgt, by = "variabele") %>%
  mutate(verschil_jaar_wgt = verschil_jaar_unpaired * weight_unpaired + verschil_jaar_paired * weight_paired,
         verschil_jaar_wgt_se = sqrt((verschil_jaar_unpaired_se * weight_unpaired)^2 + (verschil_jaar_paired_se * weight_paired)^2),
         verschil_jaar_wgt_llci = verschil_jaar_wgt - 1.96 * verschil_jaar_wgt_se,
         verschil_jaar_wgt_ulci = verschil_jaar_wgt + 1.96 * verschil_jaar_wgt_se)

results_wgt <- results_wgt %>% 
  mutate(verschil_jaar_wgt = show_ci(verschil_jaar_wgt, verschil_jaar_wgt_llci, verschil_jaar_wgt_ulci),
        diff_n_years = round(diff_n_years, 2)) %>%
  select(variabele,
         "Tijdsverschil (jaren)" = diff_n_years,
         "Jaarlijkse toename" = verschil_jaar_wgt) 

results_wgt %>% 
  datatable(rownames = FALSE)
```

### Betrouwbaarheidsinterval afleiden uit aangepaste T-test voor deels overlappende steekproef

Voor het betrouwbaarheidsinterval kunnen we ons ook baseren op de aangepaste T-test voor een deels overlappende steekproef [@Derrick2017]. Ze stellen een test-statistiek $T_{new2}$ voor met $n_1$ en $n_2$ de groottes van de steekproeven, $S_1^2$ en $S_2^2$ de steekproefvarianties van de steekproeven, $n_c$ het aantal gepaarde observaties en $r$ de correlatie tussen de gepaarde observaties:

$$T_{new2}=\frac{\bar{X_1} - \bar{X_2}}{\sqrt{\frac{S_1^2}{n_1}+\frac{S_2^2}{n_2}-2r\frac{S_1S_2n_c}{n_1n_2}}}$$

De noemer van de test-statistiek $T_{new2}$ komt overeen met de standaardfout en kan gebruikt worden om het betrouwbaarheisdsinterval af te leiden. 

De functie `Partover.test` van het R-package `Partiallyoverlapping` maakt het mogelijk om de test-statistiek te berekenen en het betrouwbaarheidsinterval op het geschatte verschil. Maar, de functie laat het niet toe om gewichten te gebruiken. Onderstaande functies houden wel rekening met de gewichten.


```{r}

wgt.var <- function(x, wgt) {
  
  v1 <- sum(wgt)
  v2 <- sum(wgt ^2)
  
  wgt.mean <- sum(wgt * x) / sum(wgt)
  
  wgt_var <- sum(wgt * (x - wgt.mean) ^ 2) / (v1 - v2 / v1)
  
  return(wgt_var)
  
}

wgt.mean_diff_pos <- function(unpaired_1, unpaired_2, paired_1, paired_2,
                              wgt_unpaired_1, wgt_unpaired_2, wgt_paired_1, wgt_paired_2) {
  
  x_1 <- c(unpaired_1, paired_1)
  x_2 <- c(unpaired_2, paired_2)
  wgt_1 <- c(wgt_unpaired_1, wgt_paired_1)
  wgt_2 <- c(wgt_unpaired_2, wgt_paired_2)
  
  wgt.mean_1 <- sum(x_1 * wgt_1) / sum(wgt_1)
  wgt.mean_2 <- sum(x_2 * wgt_2) / sum(wgt_2)
  
  wgt.var_1 <- wgt.var(x_1, wgt_1)
  wgt.var_2 <- wgt.var(x_2, wgt_2)
  
  wgt_paired <- pmin(wgt_paired_1, wgt_paired_2)
  
  wgt.mean_paired_1 <- sum(paired_1 * wgt_paired) / sum(wgt_paired)
  wgt.mean_paired_2 <- sum(paired_2 * wgt_paired) / sum(wgt_paired)
  
  wgt.var_paired_1 <- wgt.var(paired_1, wgt_paired)
  wgt.var_paired_2 <- wgt.var(paired_2, wgt_paired)
  
  n_paired <- sum(wgt_paired)
  n_1 <- sum(wgt_1)
  n_2 <- sum(wgt_2)
  
  wgt.cor <- sum(wgt_paired * (paired_1 - wgt.mean_paired_1) * (paired_2 - wgt.mean_paired_2)) / (n_paired - 1) / sqrt(wgt.var_paired_1) / sqrt(wgt.var_paired_2)
  
  wgt.mean_diff <- wgt.mean_1 - wgt.mean_2
  
  wgt.mean_diff_se <- sqrt(wgt.var_1/n_1 + wgt.var_2/n_2 - 2 * wgt.cor * (sqrt(wgt.var_1) * sqrt(wgt.var_2) * n_paired / n_1 / n_2))
  
  wgt.mean_diff_lcl = wgt.mean_diff - 1.96 * wgt.mean_diff_se
  wgt.mean_diff_ucl = wgt.mean_diff + 1.96 * wgt.mean_diff_se
  
  result <- list(wgt.mean_diff = wgt.mean_diff,
                 wgt.mean_diff_se = wgt.mean_diff_se,
                 wgt.mean_diff_lcl = wgt.mean_diff_lcl,
                 wgt.mean_diff_ucl = wgt.mean_diff_ucl)
  
  return(result)
  
}


```


```{r}

unpaired_p1 <- unpaired %>%
  filter(Periode == 1)

unpaired_p2 <- unpaired %>%
  filter(Periode == 2)

# controleer of de functie Partover.test dezelfde uitkomst geeft dan de eigen functie 'wgt.mean_diff_pos', in geval dat alle gewichten 1 zijn

check_no_weight_1 <- Partover.test(x1 = unpaired_p2$Carbon_t_ha,
              x2 = unpaired_p1$Carbon_t_ha,
              x3 = paired_p1_p2$Carbon_t_ha_2,
              x4 = paired_p1_p2$Carbon_t_ha_1,
              conf.level = 0.95)

check_no_weight_2 <- wgt.mean_diff_pos(unpaired_1 = unpaired_p2$Carbon_t_ha,
                                       unpaired_2 = unpaired_p1$Carbon_t_ha,
                                       paired_1 = paired_p1_p2$Carbon_t_ha_2,
                                       paired_2 = paired_p1_p2$Carbon_t_ha_1,
                                       wgt_unpaired_1 = rep(1, length(unpaired_p2$Carbon_t_ha)),
                                       wgt_unpaired_2 = rep(1, length(unpaired_p1$Carbon_t_ha)),
                                       wgt_paired_1 = rep(1, length(paired_p1_p2$Carbon_t_ha_2)),
                                       wgt_paired_2 = rep(1, length(paired_p1_p2$Carbon_t_ha_1)))

check_weight <- wgt.mean_diff_pos(unpaired_1 = unpaired_p2$Carbon_t_ha,
                                       unpaired_2 = unpaired_p1$Carbon_t_ha,
                                       paired_1 = paired_p1_p2$Carbon_t_ha_2,
                                       paired_2 = paired_p1_p2$Carbon_t_ha_1,
                                       wgt_unpaired_1 = unpaired_p2$Weight,
                                       wgt_unpaired_2 = unpaired_p1$Weight,
                                       wgt_paired_1 = paired_p1_p2$Weight_2,
                                       wgt_paired_2 = paired_p1_p2$Weight_1)

check <- tibble(function_used = c("Partover.test", "wgt.mean_diff_pos", "wgt.mean_diff_pos"),
                weighted = c("no", "no" , "yes"),
                estimate = c(check_no_weight_1$estimate, check_no_weight_2$wgt.mean_diff, check_weight$wgt.mean_diff),
                ci = c(str_c(check_no_weight_1$conf.int, collapse =  " "), 
                       str_c(check_no_weight_2$wgt.mean_diff_lcl, " ", check_no_weight_2$wgt.mean_diff_ucl),
                       str_c(check_weight$wgt.mean_diff_lcl, " ", check_weight$wgt.mean_diff_ucl)))


```

In onderstaande tabel zien we dat in het geval we geen gewichten gebruiken, de functie `Partover.test` quasi dezelfde uitkomst geeft als de functie `wgt.mean_diff_pos`. We zien ook het geschatte verschil kleiner is als we wel gewichten gebruiken. 


```{r}
check %>%
  datatable(rownames = FALSE,
            caption = "Vergelijking betrouwbaarheidsinterval op basis van de functie Partover.test en de functie wgt.mean_diff_pos")
```

Om de verschillen in C per jaar te bepalen moeten we bij deze methode opnieuw gebruik maken van de tijdsperiode tussen beide inventarisaties. Voor de gepaarde observaties is de tijdsperiode verschillend per plot en is het gebruik van eenzelfde tijdsperiode voor alle plots minder nauwkeurig.



```{r}
result_tnew2 <- tibble(variabele = "carbon_t_ha_diff_year",
                       estimate = check_weight$wgt.mean_diff,
                       lcl = check_weight$wgt.mean_diff_lcl,
                       ucl = check_weight$wgt.mean_diff_ucl) %>%
   bind_cols(periode_jaar) %>%
  mutate(verschil_jaar = estimate/diff_n_years,
         verschil_jaar_lcl = lcl/diff_n_years,
         verschil_jaar_ucl = ucl/diff_n_years
         )
  
result_tnew2 <- result_tnew2 %>% 
  mutate(verschil_jaar = show_ci(verschil_jaar, verschil_jaar_lcl, verschil_jaar_ucl),
        diff_n_years = round(diff_n_years, 2)) %>%
  select(variabele,
         "Tijdsverschil (jaren)" = diff_n_years,
         "Jaarlijkse toename" = verschil_jaar)

result_tnew2 %>% 
  datatable(rownames = FALSE,
            caption = "Resultaten gebaseerd op Tnew2")
  
```


# Mixed models

## Gebruik van gewichten

```{r}
analyseset <- analyseset %>%
  mutate(fPeriode = factor(Periode),
         Year_scaled = Year - min(Year),
         fReeks = factor(Reeks))

#check gebruik van gewichten

model_mean_weight <- lm(
  formula = Carbon_t_ha ~ 1,
  data = analyseset,
  weights = Weight)

model_mean_noweight <- lm(
  formula = Carbon_t_ha ~ 1,
  data = analyseset)

mean <- mean(analyseset$Carbon_t_ha)
wgt.mean <- sum(analyseset$Weight * analyseset$Carbon_t_ha) / sum(analyseset$Weight)

model_mean_intercept <- as.numeric(model_mean_noweight$coefficients)
model_wgt.mean_intercept <- as.numeric(model_mean_weight$coefficients["(Intercept)"])

check_mean <- round(mean - model_mean_intercept, 7)
check_wgt.mean <- round(wgt.mean - model_wgt.mean_intercept, 7)

model_periode_weight <- lm(
  formula = Carbon_t_ha ~ fPeriode,
  data = analyseset,
  weights = Weight)

model_periode_noweight <- lm(
  formula = Carbon_t_ha ~ fPeriode,
  data = analyseset)

mixmodel_periode_weight <- lmer(
  formula = Carbon_t_ha ~ fPeriode + (1|idplots),
  data = analyseset,
  weights = Weight)

mixmodel_periode_noweight <- lmer(
  formula = Carbon_t_ha ~ fPeriode + (1|idplots),
  data = analyseset)

mean_periode <- analyseset %>%
  group_by(Periode) %>%
  summarise(mean = mean(Carbon_t_ha),
            wgt.mean = sum(Carbon_t_ha * Weight) / sum(Weight)) %>%
  ungroup()

model_periode_weight_coeff <- cumsum(as.numeric(model_periode_weight$coefficients))
model_periode_noweight_coeff <- cumsum(as.numeric(model_periode_noweight$coefficients))
mixmodel_periode_weight_coeff <- (summary(mixmodel_periode_weight))$coefficients[,"Estimate"] %>%
  as.numeric() %>%
  cumsum()
mixmodel_periode_noweight_coeff <- (summary(mixmodel_periode_noweight))$coefficients[,"Estimate"] %>%
  as.numeric() %>%
  cumsum()

mean_periode_compare <- mean_periode %>%
  mutate(mean_lm = model_periode_noweight_coeff,
         wgt.mean_lm = model_periode_weight_coeff,
         mean_lmer = mixmodel_periode_weight_coeff,
         wgt.mean_lmer = mixmodel_periode_noweight_coeff)

#gebruik van 'weight' in lm en lmer lijkt OK op eerste zicht

```

## Dataverkenning: impact van design


```{r, fig.cap = "Invloed van observatie type en de reeks (strook van meetpunten die in bepaald jaar afgehandeld wordt) op de gemiddelde C per ha voor de beide inventarisaties"}
analyseset %>%
  ggplot(aes(x = fPeriode, y = Carbon_t_ha, colour = observation_type, shape = observation_type)) +
  stat_summary(fun.data = "mean_cl_boot", size = 0.5,  alpha = 0.5) +
  facet_wrap(~Reeks, labeller = label_both)
```

+ Verschil in gemiddeldes tussen observatie typen
+ Verschil in gemiddeldes tussen de reeksen
+ toename in gemiddeldes voor alle observatie types

```{r, fig.cap= "Aantal observaties per observatie type en per reeks"}
analyseset %>%
  ggplot(aes(x = observation_type, fill = fPeriode)) +
  geom_bar(position = "dodge") +
  facet_wrap(~Reeks, labeller = label_both) +
  coord_flip()
```

+ Duidelijk groter aandeel gepaarde metingen in eerste 4 reeksen


## Model met jaar als continue variabele

Dit model geeft de gemiddelde toename per jaar. 
Met dit model kunnen ook observaties van VBI3 eenvoudig meegenomen worden (ook als VBI3 nog niet volledig is afgerond)

We bekijken twee varianten:

+ random effect voor gepaarde plots (gepaarde plots krijgen eenzelfde id)
+ random effect voor herhaalde plots (herhaalde plots krijgen eenzelfde id)

Daarnaast evalueren we een bijkomend random effect voor:

+ observatie type
+ reeks


```{r}
mixedmodel_year_reeks <- lmer(
  formula = Carbon_t_ha ~ Year_scaled + (1 | idgroup) + (1 | fReeks),
  data = analyseset,
  weights = Weight)

mixedmodel_year <- lmer(
  formula = Carbon_t_ha ~ Year_scaled + (1 | idgroup),
  data = analyseset,
  weights = Weight)

mixedmodel_year_obs <- lmer(
  formula = Carbon_t_ha ~ Year_scaled + (1 | idgroup) + (1 | observation_type) + (1 | fReeks),
  data = analyseset,
  weights = Weight)

mixedmodel_year_2 <- lmer(
  formula = Carbon_t_ha ~ Year_scaled + (1 | idplots) + (1 | observation_type),
  data = analyseset,
  weights = Weight)

model_residuals <- bind_rows(
  analyseset %>%
    mutate(model = "mm_year_paired_reeks",
           residuals = residuals(mixedmodel_year_reeks),
           fitted = fitted(mixedmodel_year_reeks)),
  analyseset %>%
    mutate(model = "mm_year_paired",
           residuals = residuals(mixedmodel_year),
           fitted = fitted(mixedmodel_year)),
  analyseset %>%
    mutate(model = "mm_year_repetaed_obstype",
           residuals = residuals(mixedmodel_year_2),
           fitted = fitted(mixedmodel_year_2)),
  analyseset %>%
    mutate(model = "mm_year_paired_obstype",
           residuals = residuals(mixedmodel_year_obs),
           fitted = fitted(mixedmodel_year_obs))
)

```


Onderstaande grafiek toont een patroon in de residuen. 

+ Het model overschat carbon_t_ha meer en meer naarmate de gefitte waarde voor carbon_t_ha hoger wordt.
+ Het patroon is sterker als we herhaalde metingen als random effect nemen
+ Weinig impact van random effect voor observatietype en reeks

```{r}
model_residuals %>%
  ggplot(aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.1) +
  geom_smooth() +
  geom_hline(yintercept = 0, linetype = 2) +
  facet_grid(observation_type ~ model)
```

```{r}

model_residuals %>%
  ggplot(aes(x = observation_type, y = residuals)) +
  geom_boxplot() +
  facet_wrap(~model, ncol = 1) +
  coord_flip()
```

```{r}
model_residuals %>%
  ggplot(aes(x = fPeriode, y = residuals)) +
  geom_boxplot() +
  facet_wrap(~model, ncol = 4)
```
```{r}
model_residuals %>%
  ggplot(aes(x = fReeks, y = residuals)) +
  geom_boxplot() +
  facet_wrap(~model, ncol = 4)
```

```{r}

mixedmodel_year_summary <- summary(mixedmodel_year_obs)

result_mm_year <- data.frame(carbon_t_ha_diff_years = mixedmodel_year_summary$coefficients["Year_scaled","Estimate"],
                             carbon_t_ha_diff_years_se = mixedmodel_year_summary$coefficients["Year_scaled","Std. Error"]) %>%
  mutate(carbon_t_ha_diff_years_lcl = carbon_t_ha_diff_years - 1.96 * carbon_t_ha_diff_years_se,
         carbon_t_ha_diff_years_ucl = carbon_t_ha_diff_years + 1.96 * carbon_t_ha_diff_years_se,
         model_type = "Jaar als continue variabele")
```

```{r}
summary(mixedmodel_year_obs)
```



```{r icc-per-obstype, eval=FALSE}
# model random intercept for plots separately for each observation type
# don't known how to do it in lme4
library(brms)
mixedmodel_year_obs_plotid <- brm(
  formula = Carbon_t_ha | weights(Weight) ~ Year_scaled + (1 | gr(idplots, by = observation_type)) + (1 | fReeks),
  data = analyseset)
summary(mixedmodel_year_obs_plotid)
performance::icc(mixedmodel_year_obs_plotid, by_group = TRUE)
```

## Periode als verklarende variabele

We kunnen ook de periode (VBI1 en VBI2) in model opnemen om het verschil tussen de periodes te bepalen, maar dan moeten we achreraf nog het gemiddeld verschil per jaar afleiden.

```{r}
mixedmodel_periode <- lmer(
  formula = Carbon_t_ha ~ fPeriode + (1 | idgroup) + (1 | Reeks),
  data = analyseset,
  weights = Weight)

```

```{r}

mixedmodel_periode_summary <-  summary(mixedmodel_periode)

mixedmodel_periode_summary
```

Onderstaande grafiek toont een patroon in de residuen. Het model overschat carbon_t_ha meer en meer naarmate de gefitte waarde voor carbon_t_ha hoger wordt.

```{r}
plot(mixedmodel_periode)
```
```{r}
result_mm_periode <- data.frame(carbon_t_ha_diff = mixedmodel_periode_summary$coefficients["fPeriode2","Estimate"],
                             carbon_t_ha_diff_se = mixedmodel_periode_summary$coefficients["fPeriode2","Std. Error"]) %>%
  bind_cols(periode_jaar) %>%
  mutate(carbon_t_ha_diff_years = carbon_t_ha_diff / diff_n_years,
         carbon_t_ha_diff_years_se = carbon_t_ha_diff_se / diff_n_years,
         carbon_t_ha_diff_years_lcl = carbon_t_ha_diff_years - 1.96 * carbon_t_ha_diff_years_se,
         carbon_t_ha_diff_years_ucl = carbon_t_ha_diff_years + 1.96 * carbon_t_ha_diff_years_se,
         model_type = "Periode als factor")
```



```{r}
result_mm <- result_mm_periode %>%
  bind_rows(result_mm_year) %>%
  mutate(variabele = "carbon_t_ha_diff_year",
    verschil_jaar = show_ci(carbon_t_ha_diff_years, carbon_t_ha_diff_years_lcl, carbon_t_ha_diff_years_ucl),
        diff_n_years = round(diff_n_years, 2)) %>%
  select(model_type,
         variabele ,
         "Tijdsverschil (jaren)" = diff_n_years,
         "Jaarlijkse toename" = verschil_jaar) 

result_mm %>% 
  datatable(rownames = FALSE,
            caption = "Schatting jaarlijkse toename in C per ha en 95% betrouwbaarheidsinterval op basis van mixed model")
```

# Vergelijking alle methodes

```{r}
overzicht <- bind_rows(
  result_onafh %>%
    mutate(modeltype = "Design based",
           methode = "enkel onegepaard"),
  results_wgt %>%
    mutate(modeltype = "Design based",
           methode = "aparte schatting gepaard en ongepaard"),
  result_tnew2 %>%
    mutate(modeltype = "Design based",
           methode = "tnew2"),
  result_mm %>%
    mutate(modeltype = "Mixed model") %>%
    rename(methode = model_type)
) %>%
  select(modeltype, methode, variabele, "Tijdsverschil (jaren)", "Jaarlijkse toename")

datatable(overzicht,
          rownames = FALSE)
```




